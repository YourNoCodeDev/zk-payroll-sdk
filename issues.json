[
  {
    "id": 10,
    "body": "## Description\nWe need to establish the foundational repository structure. As the SDK may grow to encompass multiple packages (e.g., core, react-hooks, cli), a monorepo architecture might be beneficial.\n\n## Tasks\n- [ ] Initialize a standard `package.json` at the root.\n- [ ] Decide between **npm workspaces**, **pnpm workspaces**, or **Turborepo** (recommend evaluating Turborepo for fast builds).\n- [ ] Setup the initial `packages/core` directory for the main SDK block.\n- [ ] Ensure `tsconfig.json` base configurations are set up and can be extended.\n\n## Examples\nIf using Turborepo + npm workspaces, your `package.json` should include:\n```json\n{\n  \"workspaces\": [\"packages/*\"],\n  \"scripts\": { \"build\": \"turbo run build\" }\n}\n```\n\n## Dependencies\nNone. This is a foundational issue."
  },
  {
    "id": 11,
    "body": "## Description\nEnforcing a consistent coding standard is crucial for open-source SDKs. We need to implement ESLint and Prettier with strict TypeScript rules.\n\n## Tasks\n- [ ] Install `eslint`, `prettier`, `@typescript-eslint/eslint-plugin`, and `@typescript-eslint/parser`.\n- [ ] Create a `.eslintrc.js` and `.prettierrc` with standardized rules.\n- [ ] Add `lint` and `format` scripts to the root `package.json`.\n- [ ] Ensure the linter catches unused variables and enforces strict typing.\n\n## Examples\nA basic `.prettierrc`:\n```json\n{\n  \"semi\": true,\n  \"singleQuote\": true,\n  \"trailingComma\": \"all\",\n  \"printWidth\": 100\n}\n```\n\n## Dependencies\n- **Depends on:** #10 (Configure Monorepo Architecture)"
  },
  {
    "id": 12,
    "body": "## Description\nA robust testing framework is required to ensure the reliability of the SDK. We will use Jest with `ts-jest` for executing TypeScript tests directly.\n\n## Tasks\n- [ ] Install `jest`, `@types/jest`, and `ts-jest`.\n- [ ] Create a `jest.config.js` that properly resolving TypeScript paths.\n- [ ] Configure code coverage thresholds (e.g., minimum 80% coverage for statements, branches, functions, and lines).\n- [ ] Write a sample dummy test to verify the setup.\n\n## Examples\nSetup Coverage in `jest.config.js`:\n```js\nmodule.exports = {\n  preset: 'ts-jest',\n  coverageThreshold: {\n    global: { branches: 80, functions: 80, lines: 80, statements: 80 }\n  }\n};\n```\n\n## Dependencies\n- **Depends on:** #10 (Configure Monorepo Architecture)"
  },
  {
    "id": 17,
    "body": "## Description\nTo maintain code quality, we must ensure that no bad code gets committed. We will use Husky and `lint-staged` to run linters and formatters before every commit.\n\n## Tasks\n- [ ] Install `husky` and `lint-staged`.\n- [ ] Run `npx husky install` and set up the `pre-commit` hook.\n- [ ] Configure `lint-staged` in `package.json` to run `eslint --fix` and `prettier --write` on staged `.ts` files.\n\n## Examples\nAdd to `package.json`:\n```json\n\"lint-staged\": {\n  \"*.ts\": [\"eslint --fix\", \"prettier --write\"]\n}\n```\n\n## Dependencies\n- **Depends on:** #11 (Configure ESLint and Prettier)\n- **Depends on:** #12 (Setup Jest testing framework)"
  },
  {
    "id": 16,
    "body": "## Description\nAPI documentation is essential for SDK users. We will use TypeDoc to auto-generate static HTML documentation from our TypeScript signatures and TSDoc comments.\n\n## Tasks\n- [ ] Install `typedoc`.\n- [ ] Create a `typedoc.json` configuration specifying the entry points.\n- [ ] Add a `docs:build` script to `package.json`.\n- [ ] Ensure the generated docs are output to a `docs/` directory and excluded via `.gitignore`.\n\n## Dependencies\n- **Depends on:** #10 (Configure Monorepo Architecture)"
  },
  {
    "id": 15,
    "body": "## Description\nTo keep the SDK maintainable, we must strictly separate concerns. The layered architecture should consist of:\n1. **API Layer**: Public-facing classes and interfaces.\n2. **Core Layer**: Business logic (e.g., managing ZK proofs, payroll logic).\n3. **Adapters**: Low-level blockchain/Soroban wrappers.\n\n## Tasks\n- [ ] Create directories for `api`, `core`, and `adapters` in `src/`.\n- [ ] Define barrel files (`index.ts`) for explicit exporting, keeping internal logic private.\n- [ ] Add architecture guidelines to a `CONTRIBUTING.md` file.\n\n## Dependencies\n- **Depends on:** #10 (Configure Monorepo Architecture)"
  },
  {
    "id": 19,
    "body": "## Description\nA uniform error handling strategy makes debugging easier for developers using the SDK. We need custom error classes extending standard `Error`.\n\n## Tasks\n- [ ] Create a file `src/core/errors.ts`.\n- [ ] Define a base `ZkPayrollError` class.\n- [ ] Create specific subclasses: `NetworkError`, `ProofGenerationError`, `ContractExecutionError`, and `ValidationError`.\n- [ ] Add context metadata (e.g., `transactionId`, `code`) to these error classes.\n\n## Examples\n```typescript\nexport class ZkPayrollError extends Error {\n  constructor(message: string, public code: string) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n```\n\n## Dependencies\n- **Depends on:** #15 (Define clean architecture layers)"
  },
  {
    "id": 18,
    "body": "## Description\nZK proof generation is CPU-intensive. We need to decide whether to run it in the main thread (blocking) or offload it to a Web Worker (browser) / Worker Thread (Node.js).\n\n## Tasks\n- [ ] Research `snarkjs` Web Worker integration for the client side.\n- [ ] Define the interface `IProofGenerator` that exposes an async `generateProof()` method.\n- [ ] Draft an architecture document (`docs/zk-architecture.md`) discussing the tradeoffs and selected approach.\n\n## Dependencies\n- **Depends on:** #15 (Define clean architecture layers)"
  },
  {
    "id": 13,
    "body": "## Description\nWe require automated workflows to run on every Pull Request and Push to the `main` branch to catch bugs early.\n\n## Tasks\n- [ ] Create `.github/workflows/ci.yml`.\n- [ ] Add steps to checkout code, setup Node.js using `actions/setup-node`.\n- [ ] Run `npm ci`, `npm run lint`, `npm run typecheck`, and `npm run test`.\n- [ ] Implement caching for npm dependencies to speed up the pipeline.\n\n## Dependencies\n- **Depends on:** #11 (ESLint), #12 (Jest)"
  },
  {
    "id": 14,
    "body": "## Description\nThe SDK must be automatically published to NPM when a new release is cut. We will automate this using GitHub Actions.\n\n## Tasks\n- [ ] Create `.github/workflows/publish.yml`.\n- [ ] Setup trigger on GitHub Releases (e.g., `on: release: types: [created]`).\n- [ ] Build the SDK (`npm run build`).\n- [ ] Configure NPM authentication using `NODE_AUTH_TOKEN` secret.\n- [ ] Run `npm publish --access public`.\n\n## Dependencies\n- **Depends on:** #13 (Implement GitHub Actions for testing)"
  },
  {
    "id": 1,
    "body": "## Description\nSoroban contract interactions involve boilerplate for establishing RPC connections, building transactions, and simulating calls. We need a base wrapper class.\n\n## Tasks\n- [ ] Create `BaseContractWrapper` in the Adapters layer.\n- [ ] Implement an `invoke` method that handles simulation and execution in one go.\n- [ ] Integrate the error handling strategy to map Soroban RPC errors to our custom `ContractExecutionError`.\n\n## Examples\n```typescript\nexport abstract class BaseContractWrapper {\n  constructor(protected server: SorobanRpc.Server, protected contractId: string) {}\n  \n  protected async invoke(method: string, args: any[]): Promise<any> {\n    // Boilerplate for invoke\n  }\n}\n```\n\n## Dependencies\n- **Depends on:** #15 (Architecture layers), #19 (Error handling strategy)"
  },
  {
    "id": 2,
    "body": "## Description\nThe `PayrollService` is the primary entry point for consumers wanting to perform private transactions.\n\n## Tasks\n- [ ] Create `PayrollService` in the API layer.\n- [ ] Expose an async `processPayment({ recipient, amount, asset })` function.\n- [ ] Internally, this method should orchestrate creating the ZK Proof, building the transaction, and invoking the `BaseContractWrapper`.\n\n## Dependencies\n- **Depends on:** #1 (Contract Wrapper base class)"
  },
  {
    "id": 3,
    "body": "## Description\nIntegrate the actual ZK proof generation using `snarkjs` or a similar library to create zero-knowledge proofs directly in the client application.\n\n## Tasks\n- [ ] Add dependency on `snarkjs`.\n- [ ] Implement the `IProofGenerator` interface (from #18).\n- [ ] Write logic to fetch the `.wasm` and `.zkey` files required for proof generation.\n- [ ] Return the proof in a formatted payload ready for the smart contract verifier.\n\n## Dependencies\n- **Depends on:** #18 (ZK Proof pipeline strategy), #2 (PayrollService)"
  },
  {
    "id": 4,
    "body": "## Description\nAllowing multiple payments to be processed in a single transaction will significantly reduce gas fees. \n\n## Tasks\n- [ ] Extend `PayrollService` to include a `processBatchPayments([{ recipient, amount }])` method.\n- [ ] Adapt the ZK circuit/proof generator to handle multi-recipient proofs.\n- [ ] Update the `BaseContractWrapper` to invoke the batch endpoint on the Soroban contract.\n\n## Dependencies\n- **Depends on:** #2 (PayrollService)"
  },
  {
    "id": 5,
    "body": "## Description\nThe SDK must support alternative assets like USDC instead of just the native XLM token.\n\n## Tasks\n- [ ] Update `PayrollService` parameters to easily accept an asset contract ID.\n- [ ] Make sure asset decimals are correctly handled when calculating amounts.\n- [ ] Write integration tests proving that XLM vs USDC transfers function seamlessly.\n\n## Dependencies\n- **Depends on:** #2 (PayrollService)"
  },
  {
    "id": 6,
    "body": "## Description\nSoroban expects arguments formatted natively as XDR. We need utilities to seamlessly convert JavaScript data types into the correct format.\n\n## Tasks\n- [ ] Create `src/utils/xdr-formatters.ts`.\n- [ ] Export utilities like `numberToI128Xdr()`, `stringToScVal()`, and `addressToScAddress()`.\n- [ ] Ensure full test coverage handles edge cases like large numbers (> `Number.MAX_SAFE_INTEGER`).\n\n## Dependencies\n- **Depends on:** #1 (Contract Wrapper base class)"
  },
  {
    "id": 7,
    "body": "## Description\nTo avoid re-downloading large `.zkey` files or constantly querying non-mutable contract state, we should implement a caching mechanism.\n\n## Tasks\n- [ ] Create an abstract `CacheProvider` interface.\n- [ ] Implement `LocalStorageCacheProvider` for browser environments.\n- [ ] Implement `MemoryCacheProvider` for Node.js environments.\n- [ ] Hook into the proof generation pipeline to leverage this cache.\n\n## Dependencies\n- **Depends on:** #2 (PayrollService)"
  },
  {
    "id": 8,
    "body": "## Description\nStellar/Soroban transactions are asynchronous. Consumers need a way to know exactly when a transaction is confirmed on ledger.\n\n## Tasks\n- [ ] Add a `waitForConfirmation(txHash)` method to the SDK.\n- [ ] Implement polling using Soroban RPC `getTransaction` endpoint.\n- [ ] Expose an event emitter or Promise rejection if the transaction times out or fails on-chain.\n\n## Dependencies\n- **Depends on:** #2 (PayrollService)"
  },
  {
    "id": 9,
    "body": "## Description\nRPC endpoints can be flaky. A built-in retry mechanism prevents basic network errors from bubbling up to the user.\n\n## Tasks\n- [ ] Write a `withRetry(fn, options)` utility wrapping API calls.\n- [ ] Implement exponential backoff (e.g., 500ms, 1s, 2s, 4s).\n- [ ] Integrate this specifically into the `BaseContractWrapper` and RPC query methods.\n- [ ] Ensure `ValidationError`s are NOT retried, while `NetworkError`s are.\n\n## Dependencies\n- **Depends on:** #19 (Error handling strategy), #1 (BaseContractWrapper)"
  },
  {
    "id": 20,
    "body": "## Description\nSDK consumers need a way to build comprehensive unit tests without actually hitting a Stellar testnet or setting up their own local node.\n\n## Tasks\n- [ ] Create a `MockContractEnvironment` class.\n- [ ] Stub the responses from the `BaseContractWrapper`.\n- [ ] Allow users to inject expected return states (e.g., `mockEnv.expectInvoke('pay').toSucceed()`).\n- [ ] Document how to use the mock environment in user tests.\n\n## Dependencies\n- **Depends on:** #1 (BaseContractWrapper), #12 (Jest testing workflow)"
  }
]
